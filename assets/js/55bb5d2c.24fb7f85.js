"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[3135],{3637:(i,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>f});var n=e(4848),s=e(8453),h=e(1432);const r='package main\n\nimport "fmt"\n\nfunc main() {\n    var a int = 8\n    fmt.Println(a >> 1)  // 4\n    fmt.Println(a >> 2)  // 2\n    fmt.Println(a >> 3)  // 1\n    \n    var b int = -8\n    fmt.Println(b >> 1)  // -4\n    fmt.Println(b >> 2)  // -2\n    fmt.Println(b >> 3)  // -1\n}\n',o="4\n2\n1\n-4\n-2\n-1\n",c={title:"Right Shift Operator (`>>`)"},d=void 0,l={id:"Bit basic/rightshift/rightshift",title:"Right Shift Operator (`>>`)",description:"The right shift operator (>>) shifts the bits of its left-hand operand to the right by the number of positions specified by its right-hand operand. Each right shift operation essentially divides the number by 2 raised to the power of the number of positions shifted.",source:"@site/docs/01-Bit basic/07-rightshift/rightshift.mdx",sourceDirName:"01-Bit basic/07-rightshift",slug:"/Bit basic/rightshift/rightshift",permalink:"/GopherMasterAlgol/Bit basic/rightshift/rightshift",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/01-Bit basic/07-rightshift/rightshift.mdx",tags:[],version:"current",frontMatter:{title:"Right Shift Operator (`>>`)"},sidebar:"tutorialSidebar",previous:{title:"Left Shift Operator (`<<`)",permalink:"/GopherMasterAlgol/Bit basic/leftshift/leftshift"},next:{title:"BIT MAGIC",permalink:"/GopherMasterAlgol/Bit basic/bitmagic/bitmagic"}},a={},f=[];function g(i){const t={code:"code",li:"li",p:"p",ul:"ul",...(0,s.R)(),...i.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["The right shift operator (",(0,n.jsx)(t.code,{children:">>"}),") shifts the bits of its left-hand operand to the right by the number of positions specified by its right-hand operand. Each right shift operation essentially divides the number by ",(0,n.jsx)(t.code,{children:"2"})," raised to the power of the number of positions shifted."]}),"\n",(0,n.jsxs)(t.p,{children:["Example with ",(0,n.jsx)(t.code,{children:"var a int = 8"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Binary representation of ",(0,n.jsx)(t.code,{children:"8"}),": ",(0,n.jsx)(t.code,{children:"00001000"})]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"8 >> 1"}),": shifts the bits one position to the right, resulting in ",(0,n.jsx)(t.code,{children:"00000100"}),", which is ",(0,n.jsx)(t.code,{children:"4"})," in decimal."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"8 >> 2"}),": shifts the bits two positions to the right, resulting in ",(0,n.jsx)(t.code,{children:"00000010"}),", which is ",(0,n.jsx)(t.code,{children:"2"})," in decimal."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"8 >> 3"}),": shifts the bits three positions to the right, resulting in ",(0,n.jsx)(t.code,{children:"00000001"}),", which is ",(0,n.jsx)(t.code,{children:"1"})," in decimal."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"For signed integers:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Binary representation of ",(0,n.jsx)(t.code,{children:"-8"}),": ",(0,n.jsx)(t.code,{children:"11111000"})," (assuming two's complement)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"-8 >> 1"}),": shifts the bits one position to the right, resulting in ",(0,n.jsx)(t.code,{children:"11111100"}),", which is ",(0,n.jsx)(t.code,{children:"-4"})," in decimal."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"-8 >> 2"}),": shifts the bits two positions to the right, resulting in ",(0,n.jsx)(t.code,{children:"11111110"}),", which is ",(0,n.jsx)(t.code,{children:"-2"})," in decimal."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"-8 >> 3"}),": shifts the bits three positions to the right, resulting in ",(0,n.jsx)(t.code,{children:"11111111"}),", which is ",(0,n.jsx)(t.code,{children:"-1"})," in decimal."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"For signed integers, the behavior depends on the language implementation, but in Go, the arithmetic right shift is used, where the sign bit is copied to maintain the number's sign."}),"\n",(0,n.jsx)(t.p,{children:"Pattern explanation:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Each shift to the right discards the least significant bit (rightmost position) and copies the sign bit (leftmost position) for signed integers, effectively dividing the number by ",(0,n.jsx)(t.code,{children:"2"}),"."]}),"\n"]}),"\n",(0,n.jsx)(h.A,{language:"go",children:r}),"\n",(0,n.jsx)(t.p,{children:"Output:"}),"\n",(0,n.jsx)(h.A,{language:"text",children:o})]})}function p(i={}){const{wrapper:t}={...(0,s.R)(),...i.components};return t?(0,n.jsx)(t,{...i,children:(0,n.jsx)(g,{...i})}):g(i)}}}]);