"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[9286],{6502:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>B,contentTitle:()=>j,default:()=>A,frontMatter:()=>x,metadata:()=>k,toc:()=>w});var i=e(4848),s=e(8453),a=e(1432);const r='package main\n\nimport "fmt"\n\n\nfunc getBitWithLeftShift(num uint8, pos uint8) uint8 {\n\treturn (num >> pos) & 1\n}\n\nfunc getBitWithRightShift(num uint8, pos uint8) uint8 {\n\tvar mask uint8 = 1 << pos\n\n\tif num & mask > 0 {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n\n}\nfunc main(){\n\n\tif getBitWithLeftShift(10,3) == 1 {\n\t\tfmt.Println(1)\n\t} else{\n\t\tfmt.Println(0)\n\t}\n\n\tfmt.Println(getBitWithRightShift(10,3))\n}',l="1\n1\n",c='// clearbit/clearbit.go\n\npackage main\n\nimport "fmt"\n\n\nfunc clearBitWithRightShift(num uint8, pos uint8) uint8 {\n    var mask uint8 = ^(1 << pos)\n    return num & mask\n}\n\nfunc main() {\n    num := uint8(10) // Binary: 00001010\n\n    // Clear the bit at position 3 (counting from 0)\n    fmt.Printf("Original number: %08b\\n", num)\n\n\n    clearedWithRightShift := clearBitWithRightShift(num, 3)\n    fmt.Printf("Cleared with right shift: %08b\\n", clearedWithRightShift)\n\n}\n',h="Original number: 00001010\nCleared with right shift: 00000010\n",o='package main\n\nimport "fmt"\n\nfunc setBit(num uint8, pos uint8) uint8 {\n\tvar mark uint8 = 1 << pos\n\treturn num | mark\n}\n\nfunc main() {\n\tnum := uint8(10) // Binary: 00001010\n\t\n\tfmt.Printf("Original number: %08b\\n", num)\n\t\n\tfmt.Printf("Set Bit: %08b\\n", setBit(num, 2))\n}',u="Original number: 00001010\nSet Bit: 00001110\n",d='package main\n\nimport "fmt"\n\n// Clear the last `n` bits of the number\nfunc clearNLastBit(num uint8, n uint8) uint8 {\n\tmask := ^(uint8(1<<n) - 1)\n\tfmt.Printf("Mask : (1<<n): %08b\\n", uint8(1<<n))\n\tfmt.Printf("Mask : (1<<n) -1: %08b\\n", uint8(1<<n) -1)\n\tfmt.Printf("Mask : (^(1<<n) -1): %08b\\n", ^(uint8(1<<n) -1))\n\tfmt.Print("Search Binaray Arithmetic, If you don\'t understand. \\n")\n\treturn num & mask\n}\n\nfunc main() {\n\tnum := uint8(10) // Binary: 00001010\n\tfmt.Printf("Original number: %08b\\n", num)\n\tfmt.Printf("Cleared Last %d Bits: %08b\\n", 3, clearNLastBit(num, 3))\n}\n',m="Original number: 00001010\nMask : (1<<n): 00001000\nMask : (1<<n) -1: 00000111\nMask : (^(1<<n) -1): 11111000\nSearch Binaray Arithmetic, If you don't understand. \nCleared Last 3 Bits: 00001000\n",g='package main\n\nimport "fmt"\n\nfunc clearRangeBit(num uint8, start uint8, end uint8) uint8 {\n\tmask1 := uint8(^((1 << start) - 1))\n\tmask2 := uint8((1 << end) -1)\n\tmask := ^(mask1 & mask2)\n\tfmt.Printf("Mask1: %08b\\n", mask1)\n\tfmt.Printf("Mask2: %08b\\n", mask2)\n\tfmt.Printf("Mask: %08b\\n", mask)\n\treturn num & mask\n}\n\nfunc main(){\n\tnum := uint8(10)\n\n\tfmt.Printf("Original number: %08b\\n", num)\n\tfmt.Printf("Cleared Range: %08b\\n", clearRangeBit(num, 3, 7))\n}',f="Original number: 00001010\nMask1: 11111000\nMask2: 01111111\nMask: 10000111\nCleared Range: 00000010\n",p='package main\n\nimport "fmt"\n\nfunc clearRangeBit(num uint8, start uint8, end uint8) uint8 {\n\tmask1 := uint8(^((1 << start) - 1))\n\tmask2 := uint8((1 << end) -1)\n\tmask := ^(mask1 & mask2)\n\t\n\treturn num & mask\n}\n\nfunc replaceBits(num uint8, start uint8, end uint8, value uint8) uint8 {\n\n\tmask := clearRangeBit(num, start, end)\n\tfmt.Printf("Mask: %08b\\n", mask)\n\tfmt.Printf("Value: %08b\\n", value << start)\n\treturn (num & mask) | (value << start)\n}\n\nfunc main() {\n\n\tnum := uint8(15) // Binary: 00001111\n\tfmt.Printf("Original number: %08b\\n", num)\n\treplaceNum := uint8(5) // Binary: 00000101\n\tfmt.Printf("Replace number: %08b\\n", replaceNum)\n\tfmt.Printf("Replaced number: %08b\\n", replaceBits(num, 3, 5, replaceNum))\n\n}\n',b="Original number: 00001111\nReplace number: 00000101\nMask: 00000111\nValue: 00101000\nReplaced number: 00101111\n",x={title:"BIT MAGIC"},j=void 0,k={id:"Bit basic/bitmagic/bitmagic",title:"BIT MAGIC",description:"getBits:",source:"@site/docs/01-Bit basic/08-bitmagic/bitmagic.mdx",sourceDirName:"01-Bit basic/08-bitmagic",slug:"/Bit basic/bitmagic/bitmagic",permalink:"/GopherMasterAlgol/Bit basic/bitmagic/bitmagic",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/01-Bit basic/08-bitmagic/bitmagic.mdx",tags:[],version:"current",frontMatter:{title:"BIT MAGIC"},sidebar:"tutorialSidebar",previous:{title:"Right Shift Operator (`>>`)",permalink:"/GopherMasterAlgol/Bit basic/rightshift/rightshift"},next:{title:"Count 1's in Bit",permalink:"/GopherMasterAlgol/Bit basic/countBit/countbit"}},B={},w=[{value:"getBits:",id:"getbits",level:2},{value:"clearBit:",id:"clearbit",level:2},{value:"setBit:",id:"setbit",level:2},{value:"clearNLastBit:",id:"clearnlastbit",level:2},{value:"clearRangeBit:",id:"clearrangebit",level:2},{value:"replaceBit:",id:"replacebit",level:2}];function v(n){const t={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"getbits",children:"getBits:"}),"\n",(0,i.jsxs)(t.p,{children:["We have two options: we can use a left shift to move the number's bit to the specific position, or a right shift with ",(0,i.jsx)(t.code,{children:"1"})," to have ",(0,i.jsx)(t.code,{children:"1"})," at the specific position. Then we can perform an AND operation to check whether the bit at that position is ",(0,i.jsx)(t.code,{children:"1"})," or ",(0,i.jsx)(t.code,{children:"0"}),"."]}),"\n",(0,i.jsx)(a.A,{language:"go",children:r}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:l}),"\n",(0,i.jsx)(t.h2,{id:"clearbit",children:"clearBit:"}),"\n",(0,i.jsxs)(t.p,{children:["To clear a bit at a specific position in a number, With left shift, we shift ",(0,i.jsx)(t.code,{children:"1"})," to the specified position and then negate the mask. This mask has ",(0,i.jsx)(t.code,{children:"0"})," at the target position and ",(0,i.jsx)(t.code,{children:"1"}),"s elsewhere. We then use the AND operator with this mask to clear the bit."]}),"\n",(0,i.jsx)(a.A,{language:"go",children:c}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:h}),"\n",(0,i.jsx)(t.h2,{id:"setbit",children:"setBit:"}),"\n",(0,i.jsxs)(t.p,{children:["To clear a bit at a specific position in a number, With left shift, we shift ",(0,i.jsx)(t.code,{children:"1"})," to the specified position. We then use the OR operator with this mask to set the bit."]}),"\n",(0,i.jsx)(a.A,{language:"go",children:o}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:u}),"\n",(0,i.jsx)(t.h2,{id:"clearnlastbit",children:"clearNLastBit:"}),"\n",(0,i.jsxs)(t.p,{children:["To clear the last n bits of a number, we create a mask by left-shifting 1 by n positions, subtracting 1 from it, and then negating it. This mask has 0",(0,i.jsx)(t.code,{children:"s in the last "}),"n bits and 1",(0,i.jsx)(t.code,{children:"s elsewhere. We then use the AND operator with this mask to clear the last "}),"n bits"]}),"\n",(0,i.jsx)(a.A,{language:"go",children:d}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:m}),"\n",(0,i.jsx)(t.h2,{id:"clearrangebit",children:"clearRangeBit:"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"clearRangeBit"})," function in Go is used to clear (set to 0) a range of bits in a given number. The function takes three arguments: the number (",(0,i.jsx)(t.code,{children:"num"}),"), the starting position (",(0,i.jsx)(t.code,{children:"start"}),"), and the ending position (",(0,i.jsx)(t.code,{children:"end"}),")."]}),"\n",(0,i.jsx)(t.p,{children:"The function works as follows:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Generate Mask1"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"mask1"})," is created by left-shifting ",(0,i.jsx)(t.code,{children:"1"})," by ",(0,i.jsx)(t.code,{children:"start"})," positions and then subtracting ",(0,i.jsx)(t.code,{children:"1"}),", resulting in a mask with the last ",(0,i.jsx)(t.code,{children:"start"})," bits set to ",(0,i.jsx)(t.code,{children:"1"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:["Applying the bitwise NOT operator to ",(0,i.jsx)(t.code,{children:"mask1"})," sets all bits from ",(0,i.jsx)(t.code,{children:"0"})," to ",(0,i.jsx)(t.code,{children:"start-1"})," to ",(0,i.jsx)(t.code,{children:"0"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Generate Mask2"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"mask2"})," is created by left-shifting ",(0,i.jsx)(t.code,{children:"1"})," by ",(0,i.jsx)(t.code,{children:"end"})," positions and then subtracting ",(0,i.jsx)(t.code,{children:"1"}),", resulting in a mask with the last ",(0,i.jsx)(t.code,{children:"end"})," bits set to ",(0,i.jsx)(t.code,{children:"1"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Combine Masks"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The combined mask is created by applying a bitwise AND operation between ",(0,i.jsx)(t.code,{children:"mask1"})," and ",(0,i.jsx)(t.code,{children:"mask2"}),", followed by a bitwise NOT operation. This sets the bits in the range from ",(0,i.jsx)(t.code,{children:"start"})," to ",(0,i.jsx)(t.code,{children:"end"})," to ",(0,i.jsx)(t.code,{children:"0"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Apply Mask"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The resulting mask is applied to the original number using a bitwise AND operation, clearing the specified bit range."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(a.A,{language:"go",children:g}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:f}),"\n",(0,i.jsx)(t.p,{children:"Of course, the starting position and end position can also be considered differently based on the operator we use."}),"\n",(0,i.jsx)(t.h2,{id:"replacebit",children:"replaceBit:"}),"\n",(0,i.jsx)(t.p,{children:"Let's say you want to replace bits in number X with another bit Y at a specific index. To achieve that, we can use our previously created 'clear bit' function, left shift the value to the starting index, and perform an OR operation."}),"\n",(0,i.jsx)(a.A,{language:"go",children:p}),"\n",(0,i.jsx)(t.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:b})]})}function A(n={}){const{wrapper:t}={...(0,s.R)(),...n.components};return t?(0,i.jsx)(t,{...n,children:(0,i.jsx)(v,{...n})}):v(n)}}}]);