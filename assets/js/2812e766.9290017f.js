"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[5180],{7193:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>p,toc:()=>h});var i=r(4848),n=r(8453),o=r(1432);const s='package main\n\nimport "fmt"\n\nfunc main() {\n    var a uint8 = 12  // 1100 in binary\n    var b uint8 = 10  // 1010 in binary\n    fmt.Printf("a ^ b = %d\\n", a ^ b)  // 0110 in binary, which is 6\n}',a="a ^ b = 6\n",c={title:"XOR (`^`)"},l=void 0,p={id:"Bit basic/xor/xor",title:"XOR (`^`)",description:"The XOR operator compares each bit of the first operand to the corresponding bit of the second operand. If the bits are different, the corresponding result bit is set to 1. Otherwise, it is set to 0.",source:"@site/docs/01-Bit basic/04-xor/xor.mdx",sourceDirName:"01-Bit basic/04-xor",slug:"/Bit basic/xor/xor",permalink:"/GopherMasterAlgol/Bit basic/xor/xor",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/01-Bit basic/04-xor/xor.mdx",tags:[],version:"current",frontMatter:{title:"XOR (`^`)"},sidebar:"tutorialSidebar",previous:{title:"NOT (`^`)",permalink:"/GopherMasterAlgol/Bit basic/not/not"},next:{title:"AND NOT (&^)",permalink:"/GopherMasterAlgol/Bit basic/andnot/andnot"}},d={},h=[];function b(t){const e={p:"p",...(0,n.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"The XOR operator compares each bit of the first operand to the corresponding bit of the second operand. If the bits are different, the corresponding result bit is set to 1. Otherwise, it is set to 0."}),"\n",(0,i.jsx)(o.A,{language:"go",children:s}),"\n",(0,i.jsx)(e.p,{children:"Output:"}),"\n",(0,i.jsx)(o.A,{language:"text",children:a})]})}function u(t={}){const{wrapper:e}={...(0,n.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(b,{...t})}):b(t)}}}]);