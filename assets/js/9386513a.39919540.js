"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[4823],{5252:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>h,metadata:()=>p,toc:()=>b});var i=t(4848),r=t(8453),u=t(1432);const s='package main\n\nimport "fmt"\n\nfunc unique(num []int) int {\n\txor := 0\n\tfor i := 0; i < len(num); i++ {\n\t\txor ^= num[i]\n\t}\n\n\treturn xor\n}\n\nfunc main() {\n\tnum := []int{1, 2, 3, 4, 3, 2, 1}\n\tfmt.Println("Original Array:", num)\n\tfmt.Println("Unique Number:", unique(num))\n\n}',a="Original Array: [1 2 3 4 3 2 1]\nUnique Number: 4\n",l='package main\n\nimport "fmt"\n\nfunc unique(num []int)  {\n\txor := 0\n\tfor i := 0; i < len(num); i++ {\n\t\txor ^= num[i]\n\t}\n\t\n\tpos := 0\n\ttemp := xor\n\t\n\tfor temp&1 == 0 {\n\t\tpos++\n\t\ttemp = temp >> 1\n\t}\n\n\tmask := 1 << pos\n\n\tnum1, num2 := 0, 0\n\n\tfor i := 0; i < len(num); i++ {\n\t\tif num[i]&mask > 0 {\n\t\t\tnum1 ^= num[i]\n\t\t} else {\n\t\t\tnum2 ^= num[i]\n\t\t}\n\t}\n\n\tfmt.Println("The Unique Numbers are:" ,num1, num2)\n}\n\nfunc main() {\n\tnum := []int{1, 2, 3, 4, 5, 3, 2, 1}\n\tfmt.Println("Original Array:", num)\n\t\n\tunique(num)\t\n}',o="Original Array: [1 2 3 4 5 3 2 1]\nThe Unique Numbers are: 5 4\n",m="Original Array: [1 2 3 4 3 3 2 2 1 1]\nInside updateSum [1 0 0 0 0 0 0 0]\nInside updateSum [1 1 0 0 0 0 0 0]\nInside updateSum [2 2 0 0 0 0 0 0]\nInside updateSum [2 2 1 0 0 0 0 0]\nInside updateSum [3 3 1 0 0 0 0 0]\nInside updateSum [4 4 1 0 0 0 0 0]\nInside updateSum [4 5 1 0 0 0 0 0]\nInside updateSum [4 6 1 0 0 0 0 0]\nInside updateSum [5 6 1 0 0 0 0 0]\nInside updateSum [6 6 1 0 0 0 0 0]\nInside unique [0 0 1 0 0 0 0 0]\nThe Unique Number is: 4\n",h={title:"Check Unique Number"},c="Unique I",p={id:"Bit Problem/uniquenumber/uniquenum",title:"Check Unique Number",description:"In a set of 2n+1 numbers, where every number appears twice except for one, we can easily find the unique number. This is because the XOR operation between the same numbers results in 0, so the numbers that appear twice will cancel each other out, leaving only the unique number. To find the unique number, we can XOR all the elements in the array.",source:"@site/docs/02-Bit Problem/01-uniquenumber/uniquenum.mdx",sourceDirName:"02-Bit Problem/01-uniquenumber",slug:"/Bit Problem/uniquenumber/uniquenum",permalink:"/GopherMasterAlgol/Bit Problem/uniquenumber/uniquenum",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/02-Bit Problem/01-uniquenumber/uniquenum.mdx",tags:[],version:"current",frontMatter:{title:"Check Unique Number"},sidebar:"tutorialSidebar",previous:{title:"Bit Problem",permalink:"/GopherMasterAlgol/category/bit-problem"},next:{title:"Subset for Given String",permalink:"/GopherMasterAlgol/Bit Problem/subsets/subset"}},d={},b=[];function g(e){const n={h1:"h1",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"unique-i",children:"Unique I"}),"\n",(0,i.jsx)(n.p,{children:"In a set of 2n+1 numbers, where every number appears twice except for one, we can easily find the unique number. This is because the XOR operation between the same numbers results in 0, so the numbers that appear twice will cancel each other out, leaving only the unique number. To find the unique number, we can XOR all the elements in the array."}),"\n",(0,i.jsx)(u.A,{language:"go",children:s}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(u.A,{language:"text",children:a}),"\n",(0,i.jsx)(n.h1,{id:"unique-ii",children:"Unique II"}),"\n",(0,i.jsx)(n.p,{children:"In this problem, we have an array where every number appears twice except for two unique numbers. We need to find these two unique numbers using bitwise operations."}),"\n",(0,i.jsx)(n.p,{children:"Steps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"XOR all the elements in the array. The result will be the XOR of the two unique numbers since the XOR of a number with itself is 0 and XOR is commutative and associative."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Find the rightmost set bit: The XOR result of the two unique numbers will have at least one bit set (1). We can find the position of the rightmost set bit to differentiate between the two unique numbers."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Divide numbers into two groups: Using the set bit found in the previous step, we can divide the numbers into two groups. One group will have 1 at the found position of set bit , and the other group will not have 1 at set bit position."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"XOR within groups: XOR all numbers within each group separately. Each group will result in one of the unique numbers because all other numbers will cancel out."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(u.A,{language:"go",children:l}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(u.A,{language:"text",children:o}),"\n",(0,i.jsx)(n.h1,{id:"unique-iii",children:"Unique III"}),"\n",(0,i.jsx)(n.p,{children:"The given array follows a 3n+1 pattern, where every number appears exactly three times except for one unique number. We can find this unique number using bit manipulation. Let's break down the steps to understand how we can nullify the repeating numbers."}),"\n",(0,i.jsx)(n.p,{children:"Since we are using uint8, the numbers will be 8 bits long, so we can create an array of 8 elements to hold the sum of each bit position."}),"\n",(0,i.jsx)(n.p,{children:"Initialize a sum array:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"We create an array of 8 elements to store the sum of bits at each position across all numbers."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Sum each bit position:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"For each number in the input array, we add its bits to the corresponding positions in the sum array.\nIf a number 1 (binary 00000001) occurs 3 times, the sum array will look like [3,0,0,0,0,0,0,0].\nIf a number 2 (binary 00000010) occurs 3 times, the sum array will look like [0,3,0,0,0,0,0,0]."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Nullify repeating numbers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Since the repeating numbers contribute sums that are multiples of the repetition count (3 in this case), we can use the modulus operation to nullify these sums.\nAfter applying modulus 3 to each element in the sum array, the positions that correspond to the repeating numbers will be set to 0, while the positions corresponding to the unique number will remain non-zero."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Construct the unique number:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"By converting the remaining non-zero bits back to a single number, we can identify the unique number."}),"\n"]}),"\n",(0,i.jsx)(u.A,{language:"go",children:l}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(u.A,{language:"text",children:m})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);