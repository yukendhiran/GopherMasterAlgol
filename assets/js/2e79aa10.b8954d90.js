"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[425],{3265:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>h,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>x});var t=i(4848),o=i(8453),r=i(1432);const a='package main\n\nimport "fmt"\n\nfunc binaryExponentiation(a int, b int) int {\n\tresult := 1\n\tfor b > 0 {\n\t\tif b & 1 == 1 {\n\t\t\tresult = result * a\n\t\t}\n\t\ta = a * a\n\t\tb = b >> 1\n\t\tfmt.Printf("a = %d, b = %d, result = %d\\n", a, b, result)\n\t}\n\treturn result\n}\n\nfunc main (){\n\t aPowerB := binaryExponentiation(2, 5)\n\t fmt.Println(aPowerB)\n}',s="a = 4, b = 2, result = 2\na = 16, b = 1, result = 2\na = 256, b = 0, result = 32\n32\n",l={title:"Binary Exponentiation"},c=void 0,d={id:"Exponentiation/binary_exponentiation/binary_exponentiation",title:"Binary Exponentiation",description:"The binaryExponentiation function calculates the power of a number using an efficient method known as binary exponentiation. This method reduces the number of multiplications needed by utilizing the binary representation of the exponent.",source:"@site/docs/03-Exponentiation/01-binary_exponentiation/binary_exponentiation.mdx",sourceDirName:"03-Exponentiation/01-binary_exponentiation",slug:"/Exponentiation/binary_exponentiation/binary_exponentiation",permalink:"/GopherMasterAlgol/Exponentiation/binary_exponentiation/binary_exponentiation",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/03-Exponentiation/01-binary_exponentiation/binary_exponentiation.mdx",tags:[],version:"current",frontMatter:{title:"Binary Exponentiation"},sidebar:"tutorialSidebar",previous:{title:"Exponentiation",permalink:"/GopherMasterAlgol/category/exponentiation"}},h={},x=[{value:"Explanation",id:"explanation",level:2}];function p(n){const e={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"binaryExponentiation"})," function calculates the power of a number using an efficient method known as binary exponentiation. This method reduces the number of multiplications needed by utilizing the binary representation of the exponent."]}),"\n",(0,t.jsx)(e.h2,{id:"explanation",children:"Explanation"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"binaryExponentiation"})," function computes ( a^b ) using the following approach:"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Initialization"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"result := 1"}),": Initialize the result to 1."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsxs)(e.strong,{children:["Loop until ",(0,t.jsx)(e.code,{children:"b"})," is greater than 0"]}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"if b & 1 == 1"}),": Check if the least significant bit of ",(0,t.jsx)(e.code,{children:"b"})," is 1 (i.e., ",(0,t.jsx)(e.code,{children:"b"})," is odd).","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["If true, multiply ",(0,t.jsx)(e.code,{children:"result"})," by ",(0,t.jsx)(e.code,{children:"a"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"a = a * a"}),": Square the base ",(0,t.jsx)(e.code,{children:"a"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"b = b >> 1"}),": Right-shift the exponent ",(0,t.jsx)(e.code,{children:"b"})," by 1 (equivalent to dividing ",(0,t.jsx)(e.code,{children:"b"})," by 2)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Return the final result"}),"."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"This method effectively reduces the time complexity to ( O(\\log b) ) compared to the naive approach which has a time complexity of ( O(b) )."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.A,{language:"go",children:a}),"\n",(0,t.jsx)(e.p,{children:"Output:"}),"\n",(0,t.jsx)(r.A,{language:"text",children:s})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(p,{...n})}):p(n)}}}]);