"use strict";(self.webpackChunkgopher_master_algol=self.webpackChunkgopher_master_algol||[]).push([[6970],{4232:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>h,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var i=n(4848),r=n(8453),a=n(1432);const o="package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Example of using bit clear operator\n    var a uint8 = 0b10101010 // Binary literal for 170 in decimal\n    var b uint8 = 0b11001100 // Binary literal for 204 in decimal\n    \n    // Clear the bits in 'a' where 'b' has bits set to 1\n    result := a &^ b\n    \n    fmt.Printf(\"Result: %08b\\n\", result) // Prints: 00100010 (binary) or 34 (decimal)\n}\n",s="Result: 00100010\n",l={title:"AND NOT (&^)"},c=void 0,d={id:"Bit basic/andnot/andnot",title:"AND NOT (&^)",description:'The &^ operator in Go, known as the "bit clear" operator, is used to selectively clear bits in the left operand based on the bits set to 1 in the right operand.',source:"@site/docs/01-Bit basic/05-andnot/andnot.mdx",sourceDirName:"01-Bit basic/05-andnot",slug:"/Bit basic/andnot/andnot",permalink:"/GopherMasterAlgol/Bit basic/andnot/andnot",draft:!1,unlisted:!1,editUrl:"https://github.com/yukendhiran/GopherMasterAlgol/docs/01-Bit basic/05-andnot/andnot.mdx",tags:[],version:"current",frontMatter:{title:"AND NOT (&^)"},sidebar:"tutorialSidebar",previous:{title:"XOR (`^`)",permalink:"/GopherMasterAlgol/Bit basic/xor/xor"},next:{title:"Left Shift Operator (`<<`)",permalink:"/GopherMasterAlgol/Bit basic/leftshift/leftshift"}},h={},p=[];function b(t){const e={code:"code",p:"p",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["The ",(0,i.jsx)(e.code,{children:"&^"}),' operator in Go, known as the "bit clear" operator, is used to selectively clear bits in the left operand based on the bits set to ',(0,i.jsx)(e.code,{children:"1"})," in the right operand.\nThe bit clear operator (&^) is specific to Go"]}),"\n",(0,i.jsx)(a.A,{language:"go",children:o}),"\n",(0,i.jsx)(e.p,{children:"Output:"}),"\n",(0,i.jsx)(a.A,{language:"text",children:s})]})}function u(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(b,{...t})}):b(t)}}}]);